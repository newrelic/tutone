// Code generated by Tutone (https://github.com/newrelic/tutone)
package {{.PackageName | lower}}
{{$packageName := .PackageName}}

{{- if gt (len .Imports) 0 }}
import(
  {{- range .Imports}}
  "{{.}}"
  {{- end}}
)
{{- end}}

{{$pkgResourceName := list $packageName .Name | join "" }}

func resource{{$pkgResourceName}}() *schema.Resource {
  return &schema.Resource{
    CreateContext: resource{{$pkgResourceName}}Create,
    ReadContext:   resource{{$pkgResourceName}}Read,
    UpdateContext: resource{{$pkgResourceName}}Update,
    DeleteContext: resource{{$pkgResourceName}}Delete,
    Importer: &schema.ResourceImporter{
      StateContext: schema.ImportStatePassthroughContext,
    },
    Schema: map[string]*schema.Schema{
      {{- range .Attributes }}
        "{{.Key}}": {
          Type: schema.Type{{.Type}},
          Description: {{.Description | quote}},
          {{- if .Required }}
          Required: true,
          {{- else }}
          Optional: true,
          {{- end }}
        },
        {{- end}}
      },
    }
}

func resource{{$pkgResourceName}}Create(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
  providerConfig := meta.(*ProviderConfig)
  client := providerConfig.NewClient

  accountID := selectAccountID(providerConfig, d)

  log.Printf("[INFO] Creating New Relic One {{.Name}}")

  createInput := {{.ClientPackageName | lower }}.{{.InputObject | title }}{}
  {{- range .Attributes }}
  if attr, ok := d.GetOK({{.Key | quote}}); ok{
  createInput.{{.Key | camelcase}} = attr.({{.Type | lower}})
  }
  {{- end}}

  created, err := client.{{.ClientPackageName | title}}.{{index .ClientMethod 0}}(ctx, accountID, createInput)
  if err != nil {
    return diag.FromErr(err)
  }

  if created == nil {
    return diag.Errorf("err: {{index .ClientMethod 0}} result wasn't returned or not created.")
  }
  d.SetId(created.ID)
  return resource{{$pkgResourceName}}Read(ctx, d, meta)
}

func resource{{$pkgResourceName}}Read(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
  providerConfig := meta.(*ProviderConfig)
  client := providerConfig.NewClient

  accountID := selectAccountID(providerConfig, d)

  log.Printf("[INFO] Getting New Relic One {{.Name}}")

  resourceID := d.Id()

  resp, err :=  client.{{.ClientPackageName | title}}.{{index .ClientMethod 1}}(ctx, accountID, resourceID)
 
  if err != nil && resp == nil {
    d.SetId("")
    return nil
  }

  //Set values for import
  //err = set{{$pkgResourceName}}Attributes(d, map[string]string{
  {{- range .Attributes }}
  //  {{.Key | quote}}: ,
  {{- end}}
  //})
  //return diag.FromErr(flatten{{$pkgResourceName}}(resp, d))
  return diag.FromErr(err)
}

func resource{{$pkgResourceName}}Update(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
  providerConfig := meta.(*ProviderConfig)
  client := providerConfig.NewClient

  accountID := selectAccountID(providerConfig, d)

  log.Printf("[INFO] Updating New Relic One {{.Name}}")

  updateInput := {{.ClientPackageName | lower }}.{{.InputObject | title }}{}
  //Check for the values to be updated

  updated, err := client.{{.ClientPackageName | title}}.{{index .ClientMethod 2}}(ctx, accountID, updateInput)
  if err != nil {
    return diag.FromErr(err)
  }

  if updated == nil {
    return diag.Errorf("err: {{index .ClientMethod 2}} result wasn't returned or not updated.")
  }
 
  return resource{{$pkgResourceName}}Read(ctx, d, meta)
}

func resource{{$pkgResourceName}}Delete(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
  providerConfig := meta.(*ProviderConfig)
  client := providerConfig.NewClient

  accountID := selectAccountID(providerConfig, d)

  log.Printf("[INFO] Deleting New Relic One {{.Name}}")

  resourceID := d.Id()

  _, err :=  client.{{.ClientPackageName | title}}.{{index .ClientMethod 3}}(ctx, accountID, resourceID)
 
  if err != nil {
    return diag.FromErr(err)
  }

  return nil
}

func set{{$pkgResourceName}}Attributes(d *schema.ResourceData, attributes map[string]string) error {
	for key := range attributes {
		err := d.Set(key, attributes[key])
		if err != nil {
			return err
		}
	}

	return nil
}